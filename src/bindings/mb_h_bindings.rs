/* automatically generated by rust-bindgen 0.62.0 */

pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _ASSERT_H: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const MB_ASCII_ENABLED: u32 = 1;
pub const MB_RTU_ENABLED: u32 = 1;
pub const MB_TCP_ENABLED: u32 = 0;
pub const MB_ASCII_TIMEOUT_SEC: u32 = 1;
pub const MB_ASCII_TIMEOUT_WAIT_BEFORE_SEND_MS: u32 = 0;
pub const MB_FUNC_HANDLERS_MAX: u32 = 16;
pub const MB_FUNC_OTHER_REP_SLAVEID_BUF: u32 = 32;
pub const MB_FUNC_OTHER_REP_SLAVEID_ENABLED: u32 = 1;
pub const MB_FUNC_READ_INPUT_ENABLED: u32 = 1;
pub const MB_FUNC_READ_HOLDING_ENABLED: u32 = 1;
pub const MB_FUNC_WRITE_HOLDING_ENABLED: u32 = 1;
pub const MB_FUNC_WRITE_MULTIPLE_HOLDING_ENABLED: u32 = 1;
pub const MB_FUNC_READ_COILS_ENABLED: u32 = 1;
pub const MB_FUNC_WRITE_COIL_ENABLED: u32 = 1;
pub const MB_FUNC_WRITE_MULTIPLE_COILS_ENABLED: u32 = 1;
pub const MB_FUNC_READ_DISCRETE_INPUTS_ENABLED: u32 = 1;
pub const MB_FUNC_READWRITE_HOLDING_ENABLED: u32 = 1;
pub const MB_PDU_SIZE_MAX: u32 = 253;
pub const MB_PDU_SIZE_MIN: u32 = 1;
pub const MB_PDU_FUNC_OFF: u32 = 0;
pub const MB_PDU_DATA_OFF: u32 = 1;
pub const MB_ADDRESS_BROADCAST: u32 = 0;
pub const MB_ADDRESS_MIN: u32 = 1;
pub const MB_ADDRESS_MAX: u32 = 247;
pub const MB_FUNC_NONE: u32 = 0;
pub const MB_FUNC_READ_COILS: u32 = 1;
pub const MB_FUNC_READ_DISCRETE_INPUTS: u32 = 2;
pub const MB_FUNC_WRITE_SINGLE_COIL: u32 = 5;
pub const MB_FUNC_WRITE_MULTIPLE_COILS: u32 = 15;
pub const MB_FUNC_READ_HOLDING_REGISTER: u32 = 3;
pub const MB_FUNC_READ_INPUT_REGISTER: u32 = 4;
pub const MB_FUNC_WRITE_REGISTER: u32 = 6;
pub const MB_FUNC_WRITE_MULTIPLE_REGISTERS: u32 = 16;
pub const MB_FUNC_READWRITE_MULTIPLE_REGISTERS: u32 = 23;
pub const MB_FUNC_DIAG_READ_EXCEPTION: u32 = 7;
pub const MB_FUNC_DIAG_DIAGNOSTIC: u32 = 8;
pub const MB_FUNC_DIAG_GET_COM_EVENT_CNT: u32 = 11;
pub const MB_FUNC_DIAG_GET_COM_EVENT_LOG: u32 = 12;
pub const MB_FUNC_OTHER_REPORT_SLAVEID: u32 = 17;
pub const MB_FUNC_ERROR: u32 = 128;
pub const MB_RTU_SER_PDU_SIZE_MIN: u32 = 4;
pub const MB_RTU_SER_PDU_SIZE_MAX: u32 = 256;
pub const MB_RTU_SER_PDU_SIZE_CRC: u32 = 2;
pub const MB_RTU_SER_PDU_ADDR_OFF: u32 = 0;
pub const MB_RTU_SER_PDU_PDU_OFF: u32 = 1;
pub const MB_ASCII_DEFAULT_CR: u8 = 13u8;
pub const MB_ASCII_DEFAULT_LF: u8 = 10u8;
pub const MB_ASCII_SER_PDU_SIZE_MIN: u32 = 3;
pub const MB_ASCII_SER_PDU_SIZE_MAX: u32 = 256;
pub const MB_ASCII_SER_PDU_SIZE_LRC: u32 = 1;
pub const MB_ASCII_SER_PDU_ADDR_OFF: u32 = 0;
pub const MB_ASCII_SER_PDU_PDU_OFF: u32 = 1;
pub const MB_TCP_PORT_USE_DEFAULT: u32 = 0;
pub type wchar_t = ::core::ffi::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;

pub const TRUE: BOOL = 1;
pub const FALSE: BOOL = 0;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::core::ffi::c_ulong;
pub type ushort = ::core::ffi::c_ushort;
pub type uint = ::core::ffi::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::core::ffi::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::core::ffi::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::core::ffi::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::core::ffi::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::core::ffi::c_uint,
    pub __high: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::core::ffi::c_int,
    pub __count: ::core::ffi::c_uint,
    pub __owner: ::core::ffi::c_int,
    pub __nusers: ::core::ffi::c_uint,
    pub __kind: ::core::ffi::c_int,
    pub __spins: ::core::ffi::c_short,
    pub __elision: ::core::ffi::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::core::ffi::c_uint,
    pub __writers: ::core::ffi::c_uint,
    pub __wrphase_futex: ::core::ffi::c_uint,
    pub __writers_futex: ::core::ffi::c_uint,
    pub __pad3: ::core::ffi::c_uint,
    pub __pad4: ::core::ffi::c_uint,
    pub __cur_writer: ::core::ffi::c_int,
    pub __shared: ::core::ffi::c_int,
    pub __rwelision: ::core::ffi::c_schar,
    pub __pad1: [::core::ffi::c_uchar; 7usize],
    pub __pad2: ::core::ffi::c_ulong,
    pub __flags: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::core::ffi::c_uint; 2usize],
    pub __g_size: [::core::ffi::c_uint; 2usize],
    pub __g1_orig_size: ::core::ffi::c_uint,
    pub __wrefs: ::core::ffi::c_uint,
    pub __g_signals: [::core::ffi::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::core::ffi::c_uint;
pub type __thrd_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::core::mem::MaybeUninit<__once_flag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::core::ffi::c_uint;
pub type pthread_once_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::core::ffi::c_char; 40usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::core::ffi::c_char; 48usize],
    pub __align: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::core::ffi::c_char; 56usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::core::ffi::c_char; 8usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::core::ffi::c_char; 32usize],
    pub __align: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::core::ffi::c_char; 4usize],
    pub __align: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::core::ffi::c_uint,
        __statebuf: *mut ::core::ffi::c_char,
        __statelen: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::core::ffi::c_int,
    pub rand_deg: ::core::ffi::c_int,
    pub rand_sep: ::core::ffi::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::core::mem::MaybeUninit<random_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::core::ffi::c_uint, __buf: *mut random_data) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::core::ffi::c_uint,
        __statebuf: *mut ::core::ffi::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::core::ffi::c_char,
        __buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(__seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::core::ffi::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::core::ffi::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::core::ffi::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::core::ffi::c_ushort; 3usize],
    pub __old_x: [::core::ffi::c_ushort; 3usize],
    pub __c: ::core::ffi::c_ushort,
    pub __init: ::core::ffi::c_ushort,
    pub __a: ::core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::core::mem::MaybeUninit<drand48_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::core::ffi::c_long,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::core::ffi::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn alloca(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::core::ffi::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: ::core::ffi::c_int, __arg: *mut ::core::ffi::c_void),
        >,
        __arg: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::core::ffi::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __replace: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearenv() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::core::ffi::c_char,
        __suffixlen: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn system(__command: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::core::ffi::c_char,
        __resolved: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn labs(__x: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn llabs(__x: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::core::ffi::c_int, __denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::core::ffi::c_long, __denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::core::ffi::c_longlong, __denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::core::ffi::c_int,
        __decpt: *mut ::core::ffi::c_int,
        __sign: *mut ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::core::ffi::c_char, __n: usize) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::core::ffi::c_char,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::core::ffi::c_char, __wchar: wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::core::ffi::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::core::ffi::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::core::ffi::c_char,
        __tokens: *const *mut ::core::ffi::c_char,
        __valuep: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::core::ffi::c_char,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_uint,
        __function: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::core::ffi::c_int,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_uint,
        __function: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::core::ffi::c_char,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_int,
    ) -> !;
}
pub type __gwchar_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::core::ffi::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::core::ffi::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn rust_enter_critical();
}
extern "C" {
    pub fn rust_exit_critical();
}
#[doc = "< RTU transmission mode."]
pub const mb_mode_enum_MB_RTU: mb_mode_enum = 0;
#[doc = "< ASCII transmission mode."]
pub const mb_mode_enum_MB_ASCII: mb_mode_enum = 1;
#[doc = "< TCP mode."]
pub const mb_mode_enum_MB_TCP: mb_mode_enum = 2;
#[doc = " \\ingroup modbus"]
#[doc = " \\brief Modbus serial transmission modes (RTU/ASCII)."]
#[doc = ""]
#[doc = " Modbus serial supports two transmission modes. Either ASCII or RTU. RTU"]
#[doc = " is faster but has more hardware requirements and requires a network with"]
#[doc = " a low jitter. ASCII is slower and more reliable on slower links (E.g. modems)"]
pub type mb_mode_enum = ::core::ffi::c_uint;
#[doc = "< Read register values and pass to protocol stack."]
pub const mb_reg_mode_enum_MB_REG_READ: mb_reg_mode_enum = 0;
#[doc = "< Update register values."]
pub const mb_reg_mode_enum_MB_REG_WRITE: mb_reg_mode_enum = 1;
#[doc = " \\ingroup modbus"]
#[doc = " \\brief If register should be written or read."]
#[doc = ""]
#[doc = " This value is passed to the callback functions which support either"]
#[doc = " reading or writing register values. Writing means that the application"]
#[doc = " registers should be updated and reading means that the modbus protocol"]
#[doc = " stack needs to know the current register values."]
#[doc = ""]
#[doc = " \\see mb_reg_holding_cb(), mb_reg_coils_cb(), mb_reg_discrete_cb() and"]
#[doc = "   mb_reg_input_cb()."]
pub type mb_reg_mode_enum = ::core::ffi::c_uint;
#[doc = "< Startup finished."]
pub const mb_event_enum_EV_READY: mb_event_enum = 0;
#[doc = "< Frame received."]
pub const mb_event_enum_EV_FRAME_RECEIVED: mb_event_enum = 1;
#[doc = "< Execute function."]
pub const mb_event_enum_EV_EXECUTE: mb_event_enum = 2;
#[doc = "< Frame sent."]
pub const mb_event_enum_EV_FRAME_SENT: mb_event_enum = 3;
#[doc = " \\ingroup modbus"]
#[doc = " \\brief Event types used by all function in the protocol stack."]
pub type mb_event_enum = u8;
#[doc = "< no error."]
pub const mb_err_enum_MB_ENOERR: mb_err_enum = 0;
#[doc = "< illegal register address."]
pub const mb_err_enum_MB_ENOREG: mb_err_enum = 1;
#[doc = "< illegal argument."]
pub const mb_err_enum_MB_EINVAL: mb_err_enum = 2;
#[doc = "< porting layer error."]
pub const mb_err_enum_MB_EPORTERR: mb_err_enum = 3;
#[doc = "< insufficient resources."]
pub const mb_err_enum_MB_ENORES: mb_err_enum = 4;
#[doc = "< I/O error."]
pub const mb_err_enum_MB_EIO: mb_err_enum = 5;
#[doc = "< protocol stack in illegal state."]
pub const mb_err_enum_MB_EILLSTATE: mb_err_enum = 6;
#[doc = "< timeout error occurred."]
pub const mb_err_enum_MB_ETIMEDOUT: mb_err_enum = 7;
#[doc = "< illegal MB function."]
pub const mb_err_enum_MB_EILLFUNC: mb_err_enum = 8;
#[doc = "< master is busy now."]
pub const mb_err_enum_MB_EBUSY: mb_err_enum = 9;
#[doc = " \\ingroup modbus"]
#[doc = " \\brief Errorcodes used by all function in the protocol stack."]
pub type mb_err_enum = ::core::ffi::c_uint;
#[doc = "< Master receive frame T3.5 timeout."]
pub const mb_tmr_mode_enum_MB_TMODE_T35: mb_tmr_mode_enum = 0;
#[doc = "< Master wait respond for slave."]
pub const mb_tmr_mode_enum_MB_TMODE_RESPOND_TIMEOUT: mb_tmr_mode_enum = 1;
#[doc = "< Master sent broadcast , then delay sometime."]
pub const mb_tmr_mode_enum_MB_TMODE_CONVERT_DELAY: mb_tmr_mode_enum = 2;
#[doc = " \\ingroup modbus"]
#[doc = "  \\brief TimerMode is Master 3 kind of Timer modes."]
pub type mb_tmr_mode_enum = ::core::ffi::c_uint;
pub type BOOL = u8;
pub type UCHAR = ::core::ffi::c_uchar;
pub type CHAR = ::core::ffi::c_char;
pub type USHORT = u16;
pub type SHORT = i16;
pub type ULONG = u32;
pub type LONG = i32;
pub type DWORD = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mb_port_ser {
    _unused: [u8; 0],
}
pub type mb_port_ser_struct = _mb_port_ser;
pub type mb_port_cb_fp =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_port_cb_struct {
    #[doc = "!<pxMBFrameCBByteReceived;"]
    pub byte_rcvd: mb_port_cb_fp,
    #[doc = "!<pxMBFrameCBTransmitterEmpty;"]
    pub tx_empty: mb_port_cb_fp,
    #[doc = "!<pxMBPortCBTimerExpired;"]
    pub tmr_expired: mb_port_cb_fp,
}
#[test]
fn bindgen_test_layout_mb_port_cb_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_port_cb_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_port_cb_struct>(),
        24usize,
        concat!("Size of: ", stringify!(mb_port_cb_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_port_cb_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_port_cb_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte_rcvd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_cb_struct),
            "::",
            stringify!(byte_rcvd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_empty) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_cb_struct),
            "::",
            stringify!(tx_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmr_expired) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_cb_struct),
            "::",
            stringify!(tmr_expired)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_port_base_struct {
    #[doc = "!<Port callbacks."]
    pub cb: *mut mb_port_cb_struct,
    #[doc = "!<CB arg pointer."]
    pub arg: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_mb_port_base_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_port_base_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_port_base_struct>(),
        16usize,
        concat!("Size of: ", stringify!(mb_port_base_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_port_base_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_port_base_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_base_struct),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_base_struct),
            "::",
            stringify!(arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_trans_base_struct {
    pub port_obj: *mut mb_port_base_struct,
}
#[test]
fn bindgen_test_layout_mb_trans_base_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_trans_base_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_trans_base_struct>(),
        8usize,
        concat!("Size of: ", stringify!(mb_trans_base_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_trans_base_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_trans_base_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_trans_base_struct),
            "::",
            stringify!(port_obj)
        )
    );
}
pub type mb_frm_start_fp =
    ::core::option::Option<unsafe extern "C" fn(transport: *mut mb_trans_base_struct)>;
pub type mb_frm_stop_fp =
    ::core::option::Option<unsafe extern "C" fn(transport: *mut mb_trans_base_struct)>;
pub type mb_frm_rcv_fp = ::core::option::Option<
    unsafe extern "C" fn(
        transport: *mut mb_trans_base_struct,
        rcv_addr_buf: *mut UCHAR,
        frame_ptr_buf: *mut *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_err_enum,
>;
pub type mb_frm_snd_fp = ::core::option::Option<
    unsafe extern "C" fn(
        transport: *mut mb_trans_base_struct,
        slv_addr: UCHAR,
        frame_ptr: *const UCHAR,
        len: USHORT,
    ) -> mb_err_enum,
>;
pub type mb_get_rx_frm_fp = ::core::option::Option<
    unsafe extern "C" fn(transport: *mut mb_trans_base_struct, frame_ptr_buf: *mut *mut UCHAR),
>;
pub type mb_get_tx_frm_fp = ::core::option::Option<
    unsafe extern "C" fn(transport: *mut mb_trans_base_struct, frame_ptr_buf: *mut *mut UCHAR),
>;
pub type mb_frm_close_fp =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut mb_port_base_struct)>;
pub type mp_port_evt_post_fp = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut mb_port_base_struct, arg2: mb_event_enum),
>;
pub type mb_port_evt_get_fp = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut mb_port_base_struct,
        arg2: *mut ::core::ffi::c_void,
        arg3: *mut mb_event_enum,
    ) -> BOOL,
>;
pub type mb_mstr_rq_is_bcast_fp =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> BOOL>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_port_mtab_struct {
    #[doc = "!<pvMBFrameCloseCur;"]
    pub frm_close: mb_frm_close_fp,
    #[doc = "!<pvPortEventPostCur;"]
    pub evt_post: mp_port_evt_post_fp,
    #[doc = "!<pvPortEventGetCur;"]
    pub evt_get: mb_port_evt_get_fp,
}
#[test]
fn bindgen_test_layout_mb_port_mtab_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_port_mtab_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_port_mtab_struct>(),
        24usize,
        concat!("Size of: ", stringify!(mb_port_mtab_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_port_mtab_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_port_mtab_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frm_close) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_mtab_struct),
            "::",
            stringify!(frm_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).evt_post) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_mtab_struct),
            "::",
            stringify!(evt_post)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).evt_get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_port_mtab_struct),
            "::",
            stringify!(evt_get)
        )
    );
}
#[doc = "< No parity."]
pub const mb_port_ser_parity_enum_MB_PAR_NONE: mb_port_ser_parity_enum = 0;
#[doc = "< Odd parity."]
pub const mb_port_ser_parity_enum_MB_PAR_ODD: mb_port_ser_parity_enum = 1;
#[doc = "< Even parity."]
pub const mb_port_ser_parity_enum_MB_PAR_EVEN: mb_port_ser_parity_enum = 2;
pub type mb_port_ser_parity_enum = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief Parity used for characters in serial mode."]
    #[doc = ""]
    #[doc = " The parity which should be applied to the characters sent over the serial"]
    #[doc = " link. Please note that this values are actually passed to the porting"]
    #[doc = " layer and therefore not all parity modes might be available."]
    pub fn mb_port_ser_evt_init(inst: *mut mb_port_ser_struct) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_evt_post(inst: *mut mb_port_ser_struct, event: mb_event_enum) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_evt_get(
        inst: *mut mb_port_ser_struct,
        caller: *mut ::core::ffi::c_void,
        event: *mut mb_event_enum,
    ) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_init(
        inst: *mut mb_port_ser_struct,
        baud: ULONG,
        data_bits: UCHAR,
        parity: mb_port_ser_parity_enum,
    ) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_close(inst: *mut mb_port_ser_struct);
}
extern "C" {
    pub fn mb_port_ser_enable(inst: *mut mb_port_ser_struct, rx_enable: BOOL, tx_enable: BOOL);
}
extern "C" {
    pub fn mb_port_ser_get_byte(inst: *mut mb_port_ser_struct, byte_buf: *mut CHAR) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_put_byte(inst: *mut mb_port_ser_struct, byte_va0l: CHAR) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_tmr_init(inst: *mut mb_port_ser_struct, timeout_50us: USHORT) -> BOOL;
}
extern "C" {
    pub fn mb_port_ser_tmr_close(inst: *mut mb_port_ser_struct);
}
extern "C" {
    pub fn mb_port_ser_tmr_enable(inst: *mut mb_port_ser_struct);
}
extern "C" {
    pub fn mb_port_ser_tmr_disable(inst: *mut mb_port_ser_struct);
}
extern "C" {
    pub fn mb_port_ser_tmr_delay(inst: *mut mb_port_ser_struct, timeout_ms: USHORT);
}
pub const mb_exception_enum_MB_EX_NONE: mb_exception_enum = 0;
pub const mb_exception_enum_MB_EX_ILLEGAL_FUNCTION: mb_exception_enum = 1;
pub const mb_exception_enum_MB_EX_ILLEGAL_DATA_ADDRESS: mb_exception_enum = 2;
pub const mb_exception_enum_MB_EX_ILLEGAL_DATA_VALUE: mb_exception_enum = 3;
pub const mb_exception_enum_MB_EX_SLAVE_DEVICE_FAILURE: mb_exception_enum = 4;
pub const mb_exception_enum_MB_EX_ACKNOWLEDGE: mb_exception_enum = 5;
pub const mb_exception_enum_MB_EX_SLAVE_BUSY: mb_exception_enum = 6;
pub const mb_exception_enum_MB_EX_MEMORY_PARITY_ERROR: mb_exception_enum = 8;
pub const mb_exception_enum_MB_EX_GATEWAY_PATH_FAILED: mb_exception_enum = 10;
pub const mb_exception_enum_MB_EX_GATEWAY_TGT_FAILED: mb_exception_enum = 11;
pub type mb_exception_enum = ::core::ffi::c_uint;
pub type mb_fn_handler_fp = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::core::ffi::c_void,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_fn_handler_struct {
    pub func_code: UCHAR,
    pub handler: mb_fn_handler_fp,
}
#[test]
fn bindgen_test_layout_mb_fn_handler_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_fn_handler_struct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_fn_handler_struct>(),
        16usize,
        concat!("Size of: ", stringify!(mb_fn_handler_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_fn_handler_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_fn_handler_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_fn_handler_struct),
            "::",
            stringify!(func_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_fn_handler_struct),
            "::",
            stringify!(handler)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_tr_mtab {
    pub frm_send: mb_frm_snd_fp,
    pub frm_start: mb_frm_start_fp,
    pub frm_stop: mb_frm_stop_fp,
    pub frm_rcv: mb_frm_rcv_fp,
    pub get_rx_frm: mb_get_rx_frm_fp,
    pub get_tx_frm: mb_get_rx_frm_fp,
}
#[test]
fn bindgen_test_layout_mb_tr_mtab() {
    const UNINIT: ::core::mem::MaybeUninit<mb_tr_mtab> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_tr_mtab>(),
        48usize,
        concat!("Size of: ", stringify!(mb_tr_mtab))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_tr_mtab>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_tr_mtab))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frm_send) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_tr_mtab),
            "::",
            stringify!(frm_send)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frm_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_tr_mtab),
            "::",
            stringify!(frm_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frm_stop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_tr_mtab),
            "::",
            stringify!(frm_stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frm_rcv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_tr_mtab),
            "::",
            stringify!(frm_rcv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_rx_frm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_tr_mtab),
            "::",
            stringify!(get_rx_frm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_tx_frm) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_tr_mtab),
            "::",
            stringify!(get_tx_frm)
        )
    );
}
#[doc = "< Receiver is in initial state."]
pub const mb_rtu_rcv_state_enum_MB_RTU_RX_STATE_INIT: mb_rtu_rcv_state_enum = 0;
#[doc = "< Receiver is in idle state."]
pub const mb_rtu_rcv_state_enum_MB_RTU_RX_STATE_IDLE: mb_rtu_rcv_state_enum = 1;
#[doc = "< Frame is beeing received."]
pub const mb_rtu_rcv_state_enum_MB_RTU_RX_STATE_RCV: mb_rtu_rcv_state_enum = 2;
#[doc = "< If the frame is invalid."]
pub const mb_rtu_rcv_state_enum_MB_RTU_RX_STATE_ERROR: mb_rtu_rcv_state_enum = 3;
pub type mb_rtu_rcv_state_enum = ::core::ffi::c_uint;
#[doc = "< Transmitter is in idle state."]
pub const mb_rtu_snd_state_enum_MB_RTU_TX_STATE_IDLE: mb_rtu_snd_state_enum = 0;
#[doc = "< Transmitter is in transfer state."]
pub const mb_rtu_snd_state_enum_MB_RTU_TX_STATE_XMIT: mb_rtu_snd_state_enum = 1;
pub const mb_rtu_snd_state_enum_MB_RTU_TX_STATE_XFWR: mb_rtu_snd_state_enum = 2;
pub type mb_rtu_snd_state_enum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_rtu_tr_struct {
    pub base: mb_trans_base_struct,
    pub snd_state: mb_rtu_snd_state_enum,
    pub rcv_state: mb_rtu_rcv_state_enum,
    pub pdu_buf: [UCHAR; 256usize],
    pub snd_pdu_len: USHORT,
    pub snd_buf_cur: *mut UCHAR,
    pub snd_buf_cnt: USHORT,
    pub rcv_buf_pos: USHORT,
    pub is_master: BOOL,
    pub frame_is_broadcast: BOOL,
    pub cur_tmr_mode: mb_tmr_mode_enum,
}
#[test]
fn bindgen_test_layout_mb_rtu_tr_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_rtu_tr_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_rtu_tr_struct>(),
        304usize,
        concat!("Size of: ", stringify!(mb_rtu_tr_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_rtu_tr_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_rtu_tr_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(snd_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(rcv_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdu_buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(pdu_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_pdu_len) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(snd_pdu_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_buf_cur) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(snd_buf_cur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_buf_cnt) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(snd_buf_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_buf_pos) as usize - ptr as usize },
        290usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(rcv_buf_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_master) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(is_master)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_is_broadcast) as usize - ptr as usize },
        293usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(frame_is_broadcast)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_tmr_mode) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_rtu_tr_struct),
            "::",
            stringify!(cur_tmr_mode)
        )
    );
}
extern "C" {
    pub static mb_rtu_mtab: mb_tr_mtab;
}
extern "C" {
    pub fn mb_rtu_init(
        inst: *mut mb_rtu_tr_struct,
        is_master: BOOL,
        slv_addr: UCHAR,
        baud: ULONG,
        parity: mb_port_ser_parity_enum,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_rtu_start(inst: *mut mb_rtu_tr_struct);
}
extern "C" {
    pub fn mb_rtu_stop(inst: *mut mb_rtu_tr_struct);
}
extern "C" {
    pub fn mb_rtu_receive(
        inst: *mut mb_rtu_tr_struct,
        rcv_addr_buf: *mut UCHAR,
        frame_ptr_buf: *mut *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_rtu_send(
        inst: *mut mb_rtu_tr_struct,
        slv_addr: UCHAR,
        frame_ptr: *const UCHAR,
        len: USHORT,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_rtu_rcv_fsm(inst: *mut mb_rtu_tr_struct) -> BOOL;
}
extern "C" {
    pub fn mb_rtu_snd_fsm(inst: *mut mb_rtu_tr_struct) -> BOOL;
}
extern "C" {
    pub fn mb_rtu_tmr_35_expired(inst: *mut mb_rtu_tr_struct) -> BOOL;
}
extern "C" {
    pub fn mb_rtu_get_snd_buf(inst: *mut mb_rtu_tr_struct, frame_ptr_buf: *mut *mut UCHAR);
}
extern "C" {
    pub fn mb_rtu_get_snd_len(inst: *mut mb_rtu_tr_struct) -> USHORT;
}
extern "C" {
    pub fn mb_rtu_set_snd_len(inst: *mut mb_rtu_tr_struct, snd_pdu_len: USHORT);
}
extern "C" {
    pub fn mb_rtu_set_cur_tmr_mode(inst: *mut mb_rtu_tr_struct, tmr_mode: mb_tmr_mode_enum);
}
extern "C" {
    pub fn mb_rtu_rq_is_bcast(inst: *mut mb_rtu_tr_struct) -> BOOL;
}
#[doc = "< Receiver is in idle state."]
pub const mb_ascii_rx_state_enum_MB_ASCII_RX_STATE_IDLE: mb_ascii_rx_state_enum = 0;
#[doc = "< Frame is beeing received."]
pub const mb_ascii_rx_state_enum_MB_ASCII_RX_STATE_RCV: mb_ascii_rx_state_enum = 1;
#[doc = "< Wait for End of Frame."]
pub const mb_ascii_rx_state_enum_MB_ASCII_RX_STATE_WAIT_EOF: mb_ascii_rx_state_enum = 2;
pub type mb_ascii_rx_state_enum = ::core::ffi::c_uint;
#[doc = "< Transmitter is in idle state."]
pub const mb_ascii_tx_state_enum_MB_ASCII_TX_STATE_IDLE: mb_ascii_tx_state_enum = 0;
#[doc = "< Starting transmission (':' sent)."]
pub const mb_ascii_tx_state_enum_MB_ASCII_TX_STATE_START: mb_ascii_tx_state_enum = 1;
#[doc = "< Sending of data (Address, Data, LRC)."]
pub const mb_ascii_tx_state_enum_MB_ASCII_TX_STATE_DATA: mb_ascii_tx_state_enum = 2;
#[doc = "< End of transmission."]
pub const mb_ascii_tx_state_enum_MB_ASCII_TX_STATE_END: mb_ascii_tx_state_enum = 3;
#[doc = "< Notify sender that the frame has been sent."]
pub const mb_ascii_tx_state_enum_MB_ASCII_TX_STATE_NOTIFY: mb_ascii_tx_state_enum = 4;
pub const mb_ascii_tx_state_enum_MB_ASCII_TX_STATE_XFWR: mb_ascii_tx_state_enum = 5;
pub type mb_ascii_tx_state_enum = ::core::ffi::c_uint;
#[doc = "< Character for high nibble of byte."]
pub const mb_ascii_byte_pos_enum_BYTE_HIGH_NIBBLE: mb_ascii_byte_pos_enum = 0;
#[doc = "< Character for low nibble of byte."]
pub const mb_ascii_byte_pos_enum_BYTE_LOW_NIBBLE: mb_ascii_byte_pos_enum = 1;
pub type mb_ascii_byte_pos_enum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_ascii_tr_struct {
    pub base: mb_trans_base_struct,
    pub snd_state: mb_ascii_tx_state_enum,
    pub rcv_state: mb_ascii_rx_state_enum,
    pub pdu_buf: [UCHAR; 256usize],
    pub snd_pdu_len: USHORT,
    pub snd_buf_cur: *mut UCHAR,
    pub snd_buf_cnt: USHORT,
    pub rcv_buf_pos: USHORT,
    pub byte_pos: mb_ascii_byte_pos_enum,
    pub mb_lf_char: UCHAR,
    pub frame_is_broadcast: BOOL,
    pub is_master: BOOL,
    pub cur_tmr_mode: mb_tmr_mode_enum,
}
#[test]
fn bindgen_test_layout_mb_ascii_tr_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_ascii_tr_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_ascii_tr_struct>(),
        304usize,
        concat!("Size of: ", stringify!(mb_ascii_tr_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_ascii_tr_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_ascii_tr_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(snd_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(rcv_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdu_buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(pdu_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_pdu_len) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(snd_pdu_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_buf_cur) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(snd_buf_cur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_buf_cnt) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(snd_buf_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_buf_pos) as usize - ptr as usize },
        290usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(rcv_buf_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte_pos) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(byte_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mb_lf_char) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(mb_lf_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_is_broadcast) as usize - ptr as usize },
        297usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(frame_is_broadcast)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_master) as usize - ptr as usize },
        298usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(is_master)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_tmr_mode) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_ascii_tr_struct),
            "::",
            stringify!(cur_tmr_mode)
        )
    );
}
extern "C" {
    pub static mb_ascii_mtab: mb_tr_mtab;
}
extern "C" {
    pub fn mb_ascii_init(
        inst: *mut mb_ascii_tr_struct,
        is_master: BOOL,
        slv_addr: UCHAR,
        baud: ULONG,
        parity: mb_port_ser_parity_enum,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_ascii_start(inst: *mut mb_ascii_tr_struct);
}
extern "C" {
    pub fn mb_ascii_stop(inst: *mut mb_ascii_tr_struct);
}
extern "C" {
    pub fn mb_ascii_receive(
        inst: *mut mb_ascii_tr_struct,
        rcv_addr_buf: *mut UCHAR,
        frame_ptr_buf: *mut *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_ascii_send(
        inst: *mut mb_ascii_tr_struct,
        slv_addr: UCHAR,
        frame_ptr: *const UCHAR,
        len: USHORT,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_ascii_rcv_fsm(inst: *mut mb_ascii_tr_struct) -> BOOL;
}
extern "C" {
    pub fn mb_ascii_snd_fsm(inst: *mut mb_ascii_tr_struct) -> BOOL;
}
extern "C" {
    pub fn mb_ascii_tmr_1s_expired(inst: *mut mb_ascii_tr_struct) -> BOOL;
}
extern "C" {
    pub fn mb_ascii_get_snd_buf(inst: *mut mb_ascii_tr_struct, frame_ptr_buf: *mut *mut UCHAR);
}
extern "C" {
    pub fn mb_ascii_get_snd_len(inst: *mut mb_ascii_tr_struct) -> USHORT;
}
extern "C" {
    pub fn mb_ascii_set_snd_len(inst: *mut mb_ascii_tr_struct, snd_pdu_len: USHORT);
}
extern "C" {
    pub fn mb_ascii_set_cur_tmr_mode(inst: *mut mb_ascii_tr_struct, tmr_mode: mb_tmr_mode_enum);
}
extern "C" {
    pub fn mb_ascii_rq_is_bcast(inst: *mut mb_ascii_tr_struct) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mb_trans_union {
    pub base: mb_trans_base_struct,
    pub rtu: mb_rtu_tr_struct,
    pub ascii: mb_ascii_tr_struct,
}
#[test]
fn bindgen_test_layout_mb_trans_union() {
    const UNINIT: ::core::mem::MaybeUninit<mb_trans_union> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_trans_union>(),
        304usize,
        concat!("Size of: ", stringify!(mb_trans_union))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_trans_union>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_trans_union))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_trans_union),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rtu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_trans_union),
            "::",
            stringify!(rtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ascii) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_trans_union),
            "::",
            stringify!(ascii)
        )
    );
}
pub const mb_state_enum_STATE_ENABLED: mb_state_enum = 0;
pub const mb_state_enum_STATE_DISABLED: mb_state_enum = 1;
pub const mb_state_enum_STATE_NOT_INITIALIZED: mb_state_enum = 2;
pub type mb_state_enum = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mb_inst_struct {
    pub transport: *mut mb_trans_base_struct,
    pub port: *mut mb_port_base_struct,
    pub address: UCHAR,
    pub cur_mode: mb_mode_enum,
    pub cur_state: mb_state_enum,
    pub frame: *mut UCHAR,
    pub len: USHORT,
    pub pdu_snd_len: *mut USHORT,
    pub trmt: *mut mb_tr_mtab,
    #[doc = "!< Port method tab"]
    pub pmt: *mut mb_port_mtab_struct,
    pub func_handlers: *mut mb_fn_handler_struct,
    pub slave_id: [UCHAR; 32usize],
    pub slave_id_len: USHORT,
    pub rcv_addr: UCHAR,
    pub func_code: UCHAR,
    pub exception: mb_exception_enum,
}
#[test]
fn bindgen_test_layout_mb_inst_struct() {
    const UNINIT: ::core::mem::MaybeUninit<mb_inst_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mb_inst_struct>(),
        120usize,
        concat!("Size of: ", stringify!(mb_inst_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<mb_inst_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(mb_inst_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).transport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(cur_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur_state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(cur_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdu_snd_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(pdu_snd_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trmt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(trmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pmt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(pmt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func_handlers) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(func_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(slave_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave_id_len) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(slave_id_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_addr) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(rcv_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func_code) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(func_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exception) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(mb_inst_struct),
            "::",
            stringify!(exception)
        )
    );
}
extern "C" {
    #[doc = " \\defgroup modbus_utils Utilities"]
    #[doc = ""]
    #[doc = " This module contains some utility functions which can be used by"]
    #[doc = " the application. It includes some special functions for working with"]
    #[doc = " bitfields backed by a character array buffer."]
    #[doc = ""]
    #[doc = "  @{"]
    #[doc = ""]
    #[doc = " This function allows the efficient use of an array to implement bitfields."]
    #[doc = " The array used for storing the bits must always be a multiple of two"]
    #[doc = " bytes. Up to eight bits can be set or cleared in one operation."]
    #[doc = ""]
    #[doc = " \\param byte_buf A buffer where the bit values are stored. Must be a"]
    #[doc = "   multiple of 2 bytes. No length checking is performed and if"]
    #[doc = "   bit_offset / 8 is greater than the size of the buffer memory contents"]
    #[doc = "   is overwritten."]
    #[doc = " \\param bit_offset The starting address of the bits to set. The first"]
    #[doc = "   bit has the offset 0."]
    #[doc = " \\param but_num Number of bits to modify. The value must always be smaller"]
    #[doc = "   than 8."]
    #[doc = " \\param ucValues Thew new values for the bits. The value for the first bit"]
    #[doc = "   starting at <code>bit_offset</code> is the LSB of the value"]
    #[doc = "   <code>ucValues</code>"]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " ucBits[2] = {0, 0};"]
    #[doc = ""]
    #[doc = " // Set bit 4 to 1 (read: set 1 bit starting at bit offset 4 to value 1)"]
    #[doc = " mb_util_set_bits(ucBits, 4, 1, 1);"]
    #[doc = ""]
    #[doc = " // Set bit 7 to 1 and bit 8 to 0."]
    #[doc = " mb_util_set_bits(ucBits, 7, 2, 0x01);"]
    #[doc = ""]
    #[doc = " // Set bits 8 - 11 to 0x05 and bits 12 - 15 to 0x0A;"]
    #[doc = " mb_util_set_bits(ucBits, 8, 8, 0x5A);"]
    #[doc = " \\endcode"]
    pub fn mb_util_set_bits(
        byte_buf: *mut UCHAR,
        bit_offset: USHORT,
        but_num: UCHAR,
        ucValues: UCHAR,
    );
}
extern "C" {
    #[doc = " \\brief Function to read bits in a byte buffer."]
    #[doc = ""]
    #[doc = " This function is used to extract up bit values from an array. Up to eight"]
    #[doc = " bit values can be extracted in one step."]
    #[doc = ""]
    #[doc = " \\param byte_buf A buffer where the bit values are stored."]
    #[doc = " \\param bit_offset The starting address of the bits to set. The first"]
    #[doc = "   bit has the offset 0."]
    #[doc = " \\param but_num Number of bits to modify. The value must always be smaller"]
    #[doc = "   than 8."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = " UCHAR ucBits[2] = {0, 0};"]
    #[doc = " UCHAR ucResult;"]
    #[doc = ""]
    #[doc = " // Extract the bits 3 - 10."]
    #[doc = " ucResult = mb_util_get_bits(ucBits, 3, 8);"]
    #[doc = " \\endcode"]
    pub fn mb_util_get_bits(byte_buf: *mut UCHAR, bit_offset: USHORT, but_num: UCHAR) -> UCHAR;
}
extern "C" {
    pub fn mb_default_bool_cas(ptr: *mut BOOL, oldval: BOOL, newval: BOOL) -> BOOL;
}
extern "C" {
    pub fn mb_fn_report_slv_id(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_read_input_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_read_inp_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_read_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_read_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_write_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_write_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_write_multi_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_write_multi_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_read_coils(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_read_coils(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_write_coil(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_write_coil(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_write_multi_coils(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_write_multi_coils(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_read_discrete_inp(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_read_discrete_inputs(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_fn_rw_multi_holding_reg(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    pub fn mb_mstr_fn_rw_multi_holding_regs(
        inst: *mut mb_inst_struct,
        frame_ptr: *mut UCHAR,
        len_buf: *mut USHORT,
    ) -> mb_exception_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief Initialize the Modbus protocol stack."]
    #[doc = ""]
    #[doc = " This functions initializes the ASCII or RTU module and calls the"]
    #[doc = " init functions of the porting layer to prepare the hardware. Please"]
    #[doc = " note that the receiver is still disabled and no Modbus frames are"]
    #[doc = " processed until mb_enable() has been called."]
    #[doc = ""]
    #[doc = " \\param mode If ASCII or RTU mode should be used."]
    #[doc = " \\param slv_addr The slave address. Only frames sent to this"]
    #[doc = "   address or to the broadcast address are processed."]
    #[doc = " \\param ucPort The port to use. E.g. 1 for COM1 on windows. This value"]
    #[doc = "   is platform dependent and some ports simply choose to ignore it."]
    #[doc = " \\param baud The baudrate. E.g. 19200. Supported baudrates depend"]
    #[doc = "   on the porting layer."]
    #[doc = " \\param parity Parity used for serial transmission."]
    #[doc = ""]
    #[doc = " \\return If no error occurs the function returns mb_err_enum::MB_ENOERR."]
    #[doc = "   The protocol is then in the disabled state and ready for activation"]
    #[doc = "   by calling mb_enable(). Otherwise one of the following error codes"]
    #[doc = "   is returned:"]
    #[doc = "    - mb_err_enum::MB_EINVAL If the slave address was not valid. Valid"]
    #[doc = "        slave addresses are in the range 1 - 247."]
    #[doc = "    - mb_err_enum::MB_EPORTERR IF the porting layer returned an error."]
    pub fn mb_init(
        inst: *mut mb_inst_struct,
        transport: *mut mb_trans_union,
        mode: mb_mode_enum,
        is_master: BOOL,
        slv_addr: UCHAR,
        port_obj: *mut mb_port_base_struct,
        baud: ULONG,
        parity: mb_port_ser_parity_enum,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_init_rtu(
        inst: *mut mb_inst_struct,
        transport: *mut mb_rtu_tr_struct,
        slv_addr: UCHAR,
        port_obj: *mut mb_port_base_struct,
        baud: ULONG,
        parity: mb_port_ser_parity_enum,
    ) -> mb_err_enum;
}
extern "C" {
    pub fn mb_init_ascii(
        inst: *mut mb_inst_struct,
        transport: *mut mb_ascii_tr_struct,
        slv_addr: UCHAR,
        port_obj: *mut mb_port_base_struct,
        baud: ULONG,
        parity: mb_port_ser_parity_enum,
    ) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief Release resources used by the protocol stack."]
    #[doc = ""]
    #[doc = " This function disables the Modbus protocol stack and release all"]
    #[doc = " hardware resources. It must only be called when the protocol stack"]
    #[doc = " is disabled."]
    #[doc = ""]
    #[doc = " \\note Note all ports implement this function. A port which wants to"]
    #[doc = "   get an callback must define the macro MB_PORT_HAS_CLOSE to 1."]
    #[doc = ""]
    #[doc = " \\return If the resources where released it return mb_err_enum::MB_ENOERR."]
    #[doc = "   If the protocol stack is not in the disabled state it returns"]
    #[doc = "   mb_err_enum::MB_EILLSTATE."]
    pub fn mb_close(inst: *mut mb_inst_struct) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief Enable the Modbus protocol stack."]
    #[doc = ""]
    #[doc = " This function enables processing of Modbus frames. Enabling the protocol"]
    #[doc = " stack is only possible if it is in the disabled state."]
    #[doc = ""]
    #[doc = " \\return If the protocol stack is now in the state enabled it returns"]
    #[doc = "   mb_err_enum::MB_ENOERR. If it was not in the disabled state it"]
    #[doc = "   return mb_err_enum::MB_EILLSTATE."]
    pub fn mb_enable(inst: *mut mb_inst_struct) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief Disable the Modbus protocol stack."]
    #[doc = ""]
    #[doc = " This function disables processing of Modbus frames."]
    #[doc = ""]
    #[doc = " \\return If the protocol stack has been disabled it returns"]
    #[doc = "  mb_err_enum::MB_ENOERR. If it was not in the enabled state it returns"]
    #[doc = "  mb_err_enum::MB_EILLSTATE."]
    pub fn mb_disable(inst: *mut mb_inst_struct) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief The main pooling loop of the Modbus protocol stack."]
    #[doc = ""]
    #[doc = " This function must be called periodically. The timer interval required"]
    #[doc = " is given by the application dependent Modbus slave timeout. Internally the"]
    #[doc = " function calls mb_port_ser_evt_get() and waits for an event from the receiver or"]
    #[doc = " transmitter state machines."]
    #[doc = ""]
    #[doc = " \\return If the protocol stack is not in the enabled state the function"]
    #[doc = "   returns mb_err_enum::MB_EILLSTATE. Otherwise it returns"]
    #[doc = "   mb_err_enum::MB_ENOERR."]
    pub fn mb_poll(inst: *mut mb_inst_struct) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus"]
    #[doc = " \\brief Configure the slave id of the device."]
    #[doc = ""]
    #[doc = " This function should be called when the Modbus function <em>Report Slave ID</em>"]
    #[doc = " is enabled (By defining MB_FUNC_OTHER_REP_SLAVEID_ENABLED in mbconfig.h)."]
    #[doc = ""]
    #[doc = " \\param slv_id Values is returned in the <em>Slave ID</em> byte of the"]
    #[doc = "   <em>Report Slave ID</em> response."]
    #[doc = " \\param is_running If TRUE the <em>Run Indicator Status</em> byte is set to 0xFF."]
    #[doc = "   otherwise the <em>Run Indicator Status</em> is 0x00."]
    #[doc = " \\param slv_idstr Values which should be returned in the <em>Additional</em>"]
    #[doc = "   bytes of the <em> Report Slave ID</em> response."]
    #[doc = " \\param slv_idstr_len Length of the buffer <code>pucAdditonal</code>."]
    #[doc = ""]
    #[doc = " \\return If the static buffer defined by MB_FUNC_OTHER_REP_SLAVEID_BUF in"]
    #[doc = "   mbconfig.h is to small it returns mb_err_enum::MB_ENORES. Otherwise"]
    #[doc = "   it returns mb_err_enum::MB_ENOERR."]
    pub fn mb_set_slv_id(
        inst: *mut mb_inst_struct,
        slv_id: UCHAR,
        is_running: BOOL,
        slv_idstr: *const UCHAR,
        slv_idstr_len: USHORT,
    ) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus_registers"]
    #[doc = " \\brief Callback function used if the value of a <em>Input Register</em>"]
    #[doc = "   is required by the protocol stack. The starting register address is given"]
    #[doc = "   by \\c reg_addr and the last register is given by <tt>reg_addr +"]
    #[doc = "   reg_num - 1</tt>."]
    #[doc = ""]
    #[doc = " \\param reg_buff A buffer where the callback function should write"]
    #[doc = "   the current value of the modbus registers to."]
    #[doc = " \\param reg_addr The starting address of the register. Input registers"]
    #[doc = "   are in the range 1 - 65535."]
    #[doc = " \\param reg_num Number of registers the callback function must supply."]
    #[doc = ""]
    #[doc = " \\return The function must return one of the following error codes:"]
    #[doc = "   - mb_err_enum::MB_ENOERR If no error occurred. In this case a normal"]
    #[doc = "       Modbus response is sent."]
    #[doc = "   - mb_err_enum::MB_ENOREG If the application can not supply values"]
    #[doc = "       for registers within this range. In this case a"]
    #[doc = "       <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response."]
    #[doc = "   - mb_err_enum::MB_ETIMEDOUT If the requested register block is"]
    #[doc = "       currently not available and the application dependent response"]
    #[doc = "       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>"]
    #[doc = "       exception is sent as a response."]
    #[doc = "   - mb_err_enum::MB_EIO If an unrecoverable error occurred. In this case"]
    #[doc = "       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response."]
    pub fn mb_reg_input_cb(
        inst: *mut mb_inst_struct,
        reg_buff: *mut UCHAR,
        reg_addr: USHORT,
        reg_num: USHORT,
    ) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus_registers"]
    #[doc = " \\brief Callback function used if a <em>Holding Register</em> value is"]
    #[doc = "   read or written by the protocol stack. The starting register address"]
    #[doc = "   is given by \\c reg_addr and the last register is given by"]
    #[doc = "   <tt>reg_addr + reg_num - 1</tt>."]
    #[doc = ""]
    #[doc = " \\param reg_buff If the application registers values should be updated the"]
    #[doc = "   buffer points to the new registers values. If the protocol stack needs"]
    #[doc = "   to now the current values the callback function should write them into"]
    #[doc = "   this buffer."]
    #[doc = " \\param reg_addr The starting address of the register."]
    #[doc = " \\param reg_num Number of registers to read or write."]
    #[doc = " \\param mode If mb_reg_mode_enum::MB_REG_WRITE the application register"]
    #[doc = "   values should be updated from the values in the buffer. For example"]
    #[doc = "   this would be the case when the Modbus master has issued an"]
    #[doc = "   <b>WRITE SINGLE REGISTER</b> command."]
    #[doc = "   If the value mb_reg_mode_enum::MB_REG_READ the application should copy"]
    #[doc = "   the current values into the buffer \\c reg_buff."]
    #[doc = ""]
    #[doc = " \\return The function must return one of the following error codes:"]
    #[doc = "   - mb_err_enum::MB_ENOERR If no error occurred. In this case a normal"]
    #[doc = "       Modbus response is sent."]
    #[doc = "   - mb_err_enum::MB_ENOREG If the application can not supply values"]
    #[doc = "       for registers within this range. In this case a"]
    #[doc = "       <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response."]
    #[doc = "   - mb_err_enum::MB_ETIMEDOUT If the requested register block is"]
    #[doc = "       currently not available and the application dependent response"]
    #[doc = "       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>"]
    #[doc = "       exception is sent as a response."]
    #[doc = "   - mb_err_enum::MB_EIO If an unrecoverable error occurred. In this case"]
    #[doc = "       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response."]
    pub fn mb_reg_holding_cb(
        inst: *mut mb_inst_struct,
        reg_buff: *mut UCHAR,
        reg_addr: USHORT,
        reg_num: USHORT,
        mode: mb_reg_mode_enum,
    ) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus_registers"]
    #[doc = " \\brief Callback function used if a <em>Coil Register</em> value is"]
    #[doc = "   read or written by the protocol stack. If you are going to use"]
    #[doc = "   this function you might use the functions mb_util_set_bits() and"]
    #[doc = "   mb_util_get_bits() for working with bitfields."]
    #[doc = ""]
    #[doc = " \\param reg_buff The bits are packed in bytes where the first coil"]
    #[doc = "   starting at address \\c reg_addr is stored in the LSB of the"]
    #[doc = "   first byte in the buffer <code>reg_buff</code>."]
    #[doc = "   If the buffer should be written by the callback function unused"]
    #[doc = "   coil values (I.e. if not a multiple of eight coils is used) should be set"]
    #[doc = "   to zero."]
    #[doc = " \\param reg_addr The first coil number."]
    #[doc = " \\param coil_num Number of coil values requested."]
    #[doc = " \\param mode If mb_reg_mode_enum::MB_REG_WRITE the application values should"]
    #[doc = "   be updated from the values supplied in the buffer \\c reg_buff."]
    #[doc = "   If mb_reg_mode_enum::MB_REG_READ the application should store the current"]
    #[doc = "   values in the buffer \\c reg_buff."]
    #[doc = ""]
    #[doc = " \\return The function must return one of the following error codes:"]
    #[doc = "   - mb_err_enum::MB_ENOERR If no error occurred. In this case a normal"]
    #[doc = "       Modbus response is sent."]
    #[doc = "   - mb_err_enum::MB_ENOREG If the application does not map an coils"]
    #[doc = "       within the requested address range. In this case a"]
    #[doc = "       <b>ILLEGAL DATA ADDRESS</b> is sent as a response."]
    #[doc = "   - mb_err_enum::MB_ETIMEDOUT If the requested register block is"]
    #[doc = "       currently not available and the application dependent response"]
    #[doc = "       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>"]
    #[doc = "       exception is sent as a response."]
    #[doc = "   - mb_err_enum::MB_EIO If an unrecoverable error occurred. In this case"]
    #[doc = "       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response."]
    pub fn mb_reg_coils_cb(
        inst: *mut mb_inst_struct,
        reg_buff: *mut UCHAR,
        reg_addr: USHORT,
        coil_num: USHORT,
        mode: mb_reg_mode_enum,
    ) -> mb_err_enum;
}
extern "C" {
    #[doc = " \\ingroup modbus_registers"]
    #[doc = " \\brief Callback function used if a <em>Input Discrete Register</em> value is"]
    #[doc = "   read by the protocol stack."]
    #[doc = ""]
    #[doc = " If you are going to use his function you might use the functions"]
    #[doc = " mb_util_set_bits() and mb_util_get_bits() for working with bitfields."]
    #[doc = ""]
    #[doc = " \\param reg_buff The buffer should be updated with the current"]
    #[doc = "   coil values. The first discrete input starting at \\c reg_addr must be"]
    #[doc = "   stored at the LSB of the first byte in the buffer. If the requested number"]
    #[doc = "   is not a multiple of eight the remaining bits should be set to zero."]
    #[doc = " \\param reg_addr The starting address of the first discrete input."]
    #[doc = " \\param disc_num Number of discrete input values."]
    #[doc = " \\return The function must return one of the following error codes:"]
    #[doc = "   - mb_err_enum::MB_ENOERR If no error occurred. In this case a normal"]
    #[doc = "       Modbus response is sent."]
    #[doc = "   - mb_err_enum::MB_ENOREG If no such discrete inputs exists."]
    #[doc = "       In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent"]
    #[doc = "       as a response."]
    #[doc = "   - mb_err_enum::MB_ETIMEDOUT If the requested register block is"]
    #[doc = "       currently not available and the application dependent response"]
    #[doc = "       timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b>"]
    #[doc = "       exception is sent as a response."]
    #[doc = "   - mb_err_enum::MB_EIO If an unrecoverable error occurred. In this case"]
    #[doc = "       a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response."]
    pub fn mb_reg_discrete_cb(
        inst: *mut mb_inst_struct,
        reg_buff: *mut UCHAR,
        reg_addr: USHORT,
        disc_num: USHORT,
    ) -> mb_err_enum;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
